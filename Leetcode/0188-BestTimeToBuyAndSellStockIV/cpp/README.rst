188 Best Time to Buy and Sell Stock IV 
===================================================
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most k transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

股票买卖问题III的变种：允许执行k次事务(一次买卖是一个事务)；同样不能同时进行多个事务。


只保留峰值、谷值
--------------------------------
我们可以对prices数组进行过滤，只保留峰值、谷值，从而减少数据量。过滤过程需要O(n)时间。此过程并不是必需的。

分析1：峰值与谷值
+++++++++++++++++++++++++
结论：只有在价格处于低谷(valley)时买入，在价格处于高峰(peak)时卖出，才有可能达到最高利润，在其他任何地方进行任何买入/卖出，都无法达到最高利润。

证明：假如我们在某个不是谷值的价位买入，那么我们可以找到离该位置最近的谷值，以更低的价格买入，从而获得更高的利润；同理，假如我们在某个不是峰值的价位卖出，那么我们可以找到离该位置最近的峰值，以更高的价格卖出，从而获得更高的利润。


分析2：单次买卖与多次买卖
+++++++++++++++++++++++++
价格从一个谷值到一个邻近的峰值的过程中，我们应该只进行一次买卖(在谷值买入，峰值卖出)，还是进行多次买卖(不断买入卖出)，才能让利润更高？

设价格变化为1, 2, 3, 4, 5, 6。若我们单次买卖，利润为6 - 1 = 5；若多次买卖，由于一天只能进行一个操作，卖出之前不能再次买入，所以我们在1处买入，2处卖出，3买入，4卖出，5买入，6卖出，利润为(2 - 1) + (4 - 3) + (6 - 5) = 3。可见，单次买卖的利润更高。


结论
+++++++++++++++++++++++++
经过上述分析，得出结论，我们完全可以只保留峰值、谷值价格，因为只有在这些日子买入/卖出，才能获得最高利润，其他的价格无关紧要。去掉无关紧要的元素，有时可以让数据量大大减少，从而加快运行速度。不过这一步不是必需的。

可以设置一个新的数组valley_peak来保存这些峰谷值，空间复杂度O(n)，最坏情况下需要多占用一倍的空间。如果允许的话，也可以在原输入数组的基础上修改，不需要额外空间，最后记录下新的数组长度即可。

若决定这么做，那么修改后的第一个元素一定要为谷值。因为若第一个元素为峰值，那么第二个元素为谷值，在峰值到谷值的过程中，价格下降，我们是赚不到任何钱的，因此第一个元素若为峰值，完全是可以抛弃的。


动态规划
--------------------------------
设置一个二维数组int profit[k+1][n+1]，k为允许的最大事务数，n为prices的长度。设profit[i][j]表示，在第i次(从1开始)事务中，以prices[j-1]的价格卖出，最高可以获得多少利润。基础情况下，profit[0][j] = 0，profit[i][0] = 0，仅为方便计算。

profit[i][j]的值有两种情况：一种是我们不在prices[j-1]执行第i次事务的卖出操作，此时的利润跟上一步的利润相同::

    profit[i][j] = profit[i][j-1]
    
另一种是我们在prices[j-1]处进行卖出操作，设买入的价格为prices[m]，m ∈ [0, j-2]。那么::

    profit[i][j] = prices[j-1] - prices[m] + profit[i-1][m]
    profit[i-1][m]表示在上一次事务中，我们在prices[m]之前的位置进行了卖出操作，所获得的最大利润

我们取两者的最大值，作为profit[i][j]的值。profit[k][n]就是最终结果。

共有i个事务，prices长度为n，m取值范围是[0, j-2]，因此算法时间复杂度为O(k * n^2)，即O(n^3)级别。


优化版动态规划
--------------------------------
上述算法，计算在prices[j-1]处卖出，能获得多大利润时，花了O(n)级别的时间。如果我们能在常数时间内算出这个值，算法复杂度将被降低为O(n^2)。上述算法中::

    profit[i][j] = max(profit[i][j-1], max(price[j-1] – price[m] + profit[i-1][m])), m ∈ [0, j-1)

仔细观察发现::

    max(price[j-1] - price[m] + profit[i-1][m]) = price[j-1] + max(profit[i-1][m] - price[m]), m ∈ [0, j-1)

max(profit[i-1][m] - price[m])是可以在常数时间内求出来的。我们设置一个变量叫prev_diff，每次循环都更新它::

    prev_diff = max(prev_diff, profit[i-1][j-1] - price[j-1])

那么对于任意i和j，都有::

    prev_diff = max(profit[i-1][0] - prices[0],
                    profit[i-1][1] - prices[1],
                    ...
                    profit[i-1][j-1] - prices[j-1])
    profit[i][j] = max(profit[i][j-1], price[j-1] + prev_diff)

与原本的算法是等价的，时间复杂度却降低为O(n^2)。


O(n+klogn)算法：栈+最大堆
--------------------------------
我们对价格数据进行处理，算出所有的峰值、谷值，例如::

    valley: {v1, v2, v3, ...}
    peak:   {p1, p2, p3, ...}

当相邻的两对峰谷值(v1, p1)和(v2, p2)满足v1 <= v2且p1 <= p2时，如下图：

.. image:: simple.png

要消耗最少的事务数，获得最高的利润，有两种方案：

1. 执行2次事务，v1买入p1卖出，然后v2买入p2卖出。利润：(p1 - v1) + (p2 - v2) = (p2 - v1) + (p1 - v2)
2. 执行1次事务，v1点买入，p2点卖出。利润：(p2 - v1)。

没有更好的方案。

设置一个最大堆max_heap，保存所有方案利润，最后弹出k个最大的元素，相加起来就是最高利润。然而，我们不能简单地把两种方案的利润都放入max_heap。这是因为两种方案是互斥的。若把这两个方案的利润都放入max_heap，而两个元素都被加到总利润的话，利润就被重复计算了。

怎样不引起问题地把两个方案的利润都加到max_heap里呢？可以把p2 - v1和p1 - v2分别加入到max_heap中。如果只有p2 - v1被弹出并加到总利润中，表示我们在v1买入，p2卖出；如果两者都被弹出并加到总利润中，表示我们在v1买入，p1卖出，然后v2再买入，p2卖出。

此外，即使(p1, v1)和(p2, v2)不相邻，如果它们满足条件，也可以进行“合并”。例如下图中的情况：

.. image:: complicated.png

有三种利润最高的方案：

1. 执行3次事务，v1买入p1卖出，v2买入p2卖出，v3买入p3卖出。利润：(p1 - v1) + (p2 - v2) + (p3 - v3) = (p3 - v1) + (p1 - v3) + (p2 - v2)
2. 执行2次事务，v1买入p1卖出，v3买入p3卖出。利润：(p1 - v1) + (p3 - v3) = (p3 - v1) + (p1 - v3)
3. 执行1次事务，v1买入p3卖出。利润：(p3 - v1)

只需把p3 - v1、p1 - v3、p2 -  v2分别加入到max_heap中，其中p3 - v1 > p1 - v3 > p2 - v2。若最后3个元素都被弹出并加到总利润上，表明采用方案1；若只有前2个，表明采用方案2；若只有1个，表明采用方案3。
