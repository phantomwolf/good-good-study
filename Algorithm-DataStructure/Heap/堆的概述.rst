示例代码
==========================================
good-good-study: Algorithm-DataStructure/Heap

堆的应用
==========================================
优先级队列
----------------------------------
优先级队列可用二叉堆(Binary Heap)实现，因为它支持在O(log n)时间复杂度内完成insert()、delete()、extract_max()、decrease_key()等操作。二项堆、斐波那契堆是二叉堆的变种，它们支持在O(log n)时间复杂度内实现union操作（二叉堆里是O(n)级别）。

用堆实现的优先级队列在图算法（Prim算法、狄杰斯特拉算法）中有应用

顺序统计
----------------------------------
在统计学中，样本的第k顺序统计量（英语：Order Statistics）即它从小到大排列时的第k个值，常用于非参数估计与推断中。常见的顺序统计量包括样本的最大值、最小值、中位数等。堆可以有效地解决该问题。

堆的构建
==========================================
一个堆可以从空堆开始，一点一点往里插入数据，来构建出来，但这并不是最快的方法。

更快的方法（由Floyd发明）是，从一个充满元素但性质已被破坏的堆开始（即假定一开始整个数组的元素都在堆里），一点一点修复它。堆的结构是二叉树，我们从这棵树的最下层开始，不断对子树的根调用heapify，将其沉到下面去。这样，慢慢的，堆的性质被从下往上修复。伪代码::

    Build-Max-Heap (A):
        heap_length[A] ← length[A]
    
        for each index i from floor(length[A]/2) downto 1 do:
            Max-Heapify(A, i)

堆的性能
==========================================
以下性能均为最坏情况。渐进符号::

    Θ 上下界
    O 上界(最坏情况)
    Ω 下界(最好情况)

+---------------+-----------+-----------+-----------+-----------+-----------+---------------+-------------------+
| Operation     | Binary    | Binomial  | Fibonacci | Pairing   | Brodal    | Rank-pairing  | Strict Fibonacci  |
+===============+===========+===========+===========+===========+===========+===============+===================+
| find-min      | Θ(1)      | Θ(log n)  | Θ(1)      | Θ(1)      | Θ(1)      | Θ(1)          | Θ(1)              |
+---------------+-----------+-----------+-----------+-----------+-----------+---------------+-------------------+
| delete-min    | Θ(log n)  | Θ(log n)  | O(log n)  | O(log n)  | O(log n)  | O(log n)      | O(log n)          |
+---------------+-----------+-----------+-----------+-----------+-----------+---------------+-------------------+
| insert        | O(log n)  | Θ(1)      | Θ(1)      | Θ(1)      | Θ(1)      | Θ(1)          | Θ(1)              |
+---------------+-----------+-----------+-----------+-----------+-----------+---------------+-------------------+
| decrease-key  | Θ(log n)  | Θ(log n)  | Θ(1)      | o(log n)  | Θ(1)      | Θ(1)          | Θ(1)              |
+---------------+-----------+-----------+-----------+-----------+-----------+---------------+-------------------+
| merge         | Θ(n)      | O(log n)  | Θ(1)      | Θ(1)      | Θ(1)      | Θ(1)          | Θ(1)              |
+---------------+-----------+-----------+-----------+-----------+-----------+---------------+-------------------+

为什么堆更适合优先级队列？
----------------------------------
一个典型的优先级队列需要以下操作得以高效地进行：

1. 获取优先级最高的元素(获取最大值或最小值)
2. 插入元素
3. 移除优先级最高的元素
4. 减少某个元素的优先级

二叉堆可以用以下时间复杂度实现这些操作：

1. O(1)
2. O(log n)
3. O(log n)
4. O(log n)

一个自平衡二叉搜索数（AVL、红黑树）也能在相同的优先级内实现这些操作

1. 可以保存一个额外指针，指向树中的最小值或最大值(一直向左或向右前进即可)。如果该元素被删除，只需寻找中序遍历的后继结点即可。
2. 插入元素：O(log n)
3. 删除最大、最小元素：O(log n)
4. 可以先删除该元素，将其key减小后，再插入。优先级也是O(log n)

所以为什么在实现优先级队列时，堆比树更好？

- 二叉堆是用数组实现的，符合“引用本地化”原则，缓存性能更好
- 二叉搜索树的常数因子更大
- 二叉堆只需O(log n)的时间来构建，而平衡二叉搜索书需要O(nlog n)
- 二叉堆不需要额外空间来存储指针(left、right、parent)
- 二叉堆更易于实现
- 二叉堆的变种，比如斐波那契堆，支持在O(1)时间复杂度里实现insert()和decrease_key()操作

二叉堆永远更好么？二叉搜索树的优点在哪里？

- 在平衡二叉树中搜索元素需要O(log n)时间，但在二叉堆里是O(n)
- 可以在O(n)时间内按顺序将二叉搜索树中的元素打印，即中序遍历；但二叉堆需要O(nlog n)时间，即堆排序。
- 二叉搜索树中，元素的上界(ceiling)和下界(floor)可以在O(log n)时间内被找到：http://www.geeksforgeeks.org/floor-and-ceil-from-a-bst/
- 在一些额外参数的帮助下，第k个最大/最小的元素，可以在O(log n)时间内找到：http://www.geeksforgeeks.org/find-k-th-smallest-element-in-bst-order-statistics-in-bst/
