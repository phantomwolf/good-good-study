第1章 打开新世界大门
==============================
- 定义正确的问题：遇到问题时，不要急着去写代码。要正确地定义问题，利用问题中的每一项条件，才能写出最优的代码。
- 简单的设计：一般来说，简单的设计也是可靠的设计。当你再也无法从设计中去除任何一样东西了，说明你的设计已经达到最简化状态了。


第2章 算法
==============================
排序
------------------
排序，是解决很多问题的先决条件。很多算法要求在有序的序列上执行。

签名Signature
------------------
数据本身有时会不便操作。这时，用一定的运算，为数据生成一个签名，可能会让程序变得更简单。例如在anagram问题中，将每个单词字母排序后生成一个签名，互为anagram的单词们的签名一样，只要比较签名，很容易就能找到所有的anagram。


第3章 数据结构
===============================

- 本章提醒大家用合适的数据结构来存储数据，会达到事半功倍的效果。设计程序时要从数据开始思考，然后才是程序的流程。
- 解决一个特定的问题时，最简单的是解决一个通用问题，然后将特定的条件代入其中。


第4章 写出正确的程序
===============================
本章谈到如何保证程序的正确性。除了测试以外，还可以直接检查代码。以下是代码检查的技巧:

函数
--------------------------
函数可以被视为一个原子操作，一旦对函数的功能检查完毕后，就应当信任函数完成了工作，并以此为前提条件，进行下一步的检查。

分支结构(if...else...)
--------------------------
在相应的分支里，可以认为相应的条件为真。(废话，不然程序也不会执行到那里)

循环结构
--------------------------
循环不变性（loop invariant，或“循环不变量”），是一组在循环体内、每次迭代均保持为真的性质，通常被用来证明程式或伪码的正确性（有时但较少情况下用以证明算法的正确性）。循环结构有3个阶段：初始化，保持，结束。要验证循环的正确性，首先，验证初始化过后，这种性质为真；其次，验证每次循环过后，这种性质依然保持；最后，验证循环结束时，结果是我们想要的。


第5章 编程中的小事
===============================
从伪代码到实际代码
------------------------
写程序之前先写伪代码，会让思路清晰，减少错误。

基本的测试/debug
------------------------
程序写好后，先用简单的测试用例测试一下，还可以用边界值来找出bug。

断言Assertion
------------------------
C语言中，assert.h定义了一个函数assert(scalar expression)，可以用来检查表达式的值。如果NDEBUG被定义，assert函数不会编译出任何代码，因此对性能没有任何影响。

自动化测试
------------------------
比如，我们可以用随机数，产生一个很大的输入集合，来对程序进行测试。

CPU时钟数
------------------------
time.h中的函数clock(void)可返回CPU时钟数，可以用来计算不同算法消耗的的CPU资源，从而判断算法的效率。函数返回值为clock_t，即long unsigned int。


第6章 性能的视角
===============================
设计层级
------------------------
一个电脑系统是在很多不同的级别上设计出来的，上至软件架构，下至硬件设备。

- 问题定义：良好的定义，是解决问题的第一步，也是最重要的一步。放到商业项目上，就是需要跟客户沟通，最终确定合同。如果需求比较模糊，可以用敏捷开发模式。
- 系统架构：将庞大的系统分解为模块。对系统完成后的性能、能承受的负载作出估计。如果架构没设计好，软件完成后很难达到要求。
- 算法与数据结构：写成高性能模块的关键在于合适的算法与数据结构。好的算法能从数量级上碾压坏的算法，这是小的优化技巧难以达到的。
- 代码调优：一些优化技巧（比如循环展开）可以减少程序开销的常数因子。
- 系统软件：操作系统、数据库、编译器的优化选项等等。
- 硬件：更快的CPU、显卡、固态硬盘等。

找出瓶颈，选择最合适的层级进行优化。


第7章 性能估算
==============================



第8章 算法设计技术
==============================
保存状态，避免重复计算
-------------------------
例如，动态规划中，就是用数组保存子问题的结果，来避免重复计算。

将信息预处理为数据结构
-------------------------
将数据处理并存放到数据结构中，能大大加快运行速度，方便下一步的工作。

分治法
-------------------------
将一个大问题，分解为多个独立的子问题，再把子问题的结果合并。

扫描算法
-------------------------
思路：如何把问题从x[0...i-1]扩展到x[0...i]。

累积
-------------------------
设有一个数组x[10]，如何快速算出x[i] + x[i+1] + ... + x[j]呢？可以设置一个数组y[10]，遍历数组x，令y[i] = x[0] + x[1] + ... + x[i]。这样x[i] + x[i+1] + ... + x[j] = y[j] - y[i-1]。

性能的下界/最差性能
-------------------------
设计算法时，常常考虑算法的最差性能，因为最差性能相当于一种担保，保证在任何条件下，算法的性能都不会低于这个值。有时也考虑平均性能，比如快速排序，但是要想办法避免最坏结果。


第9章 代码调优
==============================
优化技巧
-------------------------
- 缓存：将数据库中、磁盘上最常用的数据缓存到内存中，可以提高性能
- 分配策略：系统调用是相对较慢的。分配内存时，最好用一次大量的内存申请来替代多次少量的申请。
- 替代昂贵的运算：有些运算（比如%）要比其他运算（加减）更昂贵。如果可以用普通运算替代它们，可以提高性能。
- 宏/内联函数：省去了函数调用的开销
- 循环展开：循环结构中含有jump指令，会导致CPU预测指令失败，花更多的时间加载指令。要减少这种开销，充分利用CPU的预测，就要减少循环的次数。为此，我们可以将循环展开，在一次循环里处理原本多次循环的任务，多写几句重复的代码，以二进制文件的增大，换取性能的提升。
- 数据结构：改变数据的表现方式（比如将经纬度换成x、y、z坐标），可能会减少计算量。
- 内存的特性：访问内存的最快方式就是连续访问，这样缓存预测成功率高。因此，数组一般都比链表要快。
- 磁盘的特性：最好的方式是顺序、大量读取/写入。磁盘的读写较慢，尽管操作系统有缓存，还是应该一次大量读写，以减少读写次数。

原则
-------------------------
- 效率的角色：软件的其他特性（比如可维护性）也跟效率同样重要。过早的优化容易导致问题。不可随意因效率而牺牲其他特性。
- 测量工具：当效率很重要时，第一步应该对软件做profiling，找出最耗时的地方，有针对性地优化。
- 设计层级：在优化代码之前，先想想是否在其他的层级上优化更好，比如重新设计架构、换一个算法/数据结构、换一个数据库。
- 越优化越慢：一些看似聪明的“优化”反而会使软件变慢，因此优化结束后，需要重新测试一下性能。


第10章 压缩空间
===============================
减少存储空间的技术
----------------------------
- 不要储存，重新计算：为了节约空间，可以写一个代码即时生成所需的数据，而不是储存起来。
- 稀疏数据结构：比如稀疏矩阵，对于一个m行n列的矩阵，准备一个长度为m的数组，其中每个元素都是一个链表的表头，链表中每一个结点都是矩阵中的一项数据，结点中需要记录列号。
- 数据压缩：对于小于256的数，用char类型来存储；对个位数a和b，可以这样存储c = a*10 + b。
- 分配策略：使用动态分配策略，需要的时候再分配。
- 垃圾回收：充分利用空闲空间，比如某结构体内的元素的内存是按照4字节对齐的，那么其地址的最后2位必然为0，因此这两位可以用来存储数据；比如一个对称的矩阵，存放到数组中，会有一半的空间被浪费掉，这一半的空间可以用来存放另一个对称的矩阵（当i=j时，值相等）

减少代码大小的技术
---------------------------
- 函数：将重复的代码定义为函数
- 解释器：将复杂的操作，写成指令（字符串），然后用解释器来解释它们，执行相应的操作。
- 编译器：比如gcc有-Os选项，可以减少代码大小。

原则
---------------------------
- 空间的开销：在一些系统上，多占用10%内存几乎没有影响；在另一些系统上，电脑就有可能因内存不足而崩溃。在网络上传输数据，多用10%空间就会多花10%的时间。多占用一些空间，原来在L1缓存中的数据，就有可能必须存放到L2缓存中，甚至内存和磁盘上，显著降低性能。在优化空间占用时，最好知道这些空间的开销。
- 空间占用热点：程序的某些部分占用的空间比别的地方多得多，比如生成大量object/record的地方。在这些地方优化，事半功倍。
- 测量空间
- 权衡：有时必须牺牲性能，减少空间占用。但是在作出权衡之前，先寻找两全其美的方法。
- 顺应环境
- 对症下药


第11章 排序
==============================
本章介绍了C标准库里的qsort，以及几个优化快速排序的方法。


第12章 一个取样问题
==============================
本章探讨了如何从0-n的范围内，随机选出m个数的问题。

Knuth《编程之道》中的一个算法
-----------------------------
如果运气不好，之前产生的随机数都不满足rand() % (n-i) < m也不用担心，这个算法必定会成功。随着i逐渐接近n，n-i的值逐渐接近0，不论rand()产生什么样的随机数，到了最后rand() % (n-i)也一定会小于m::

    void genknuth(int m, int n)
    {
        for (int i = 0; i < n; i++) {
            if ((rand() % (n-i)) < m) {
                cout << i << endl;
                m--;
            }
        }
    }

使用set
---------------------
不断生成随机数，直到set的大小达到m为止，反正set数据结构可以覆盖掉重复的内容::

	void gensets(int m, int n)
	{
		// C++ STL中的set是红黑树，unordered_set是散列表。如果不要求结果有序，可以用后者提高性能。
		set<int> S;
		while (S.size() < m) {
			S.insert(rand() % n);
		}
		set<int>::iterator i;
		for (i = S.begin(); i != S.end(); i++) {
			cout << *i << endl;
		}
	}

Knuth Shuffle算法
---------------------
一种原地洗牌算法。对数组a，不断从右半部分随机选出一个数，与数组左半部分的数互换。最后，数组的左边m个数是经过洗牌的::

	-- To shuffle an array a of n elements (indices 0..n-1):
	for i from 0 to n−2 do
		j ← random integer such that i ≤ j < n
		exchange a[i] and a[j]

Inside-out Knuth Shuffle算法
------------------------------
与上一个算法类似，但是产生一个新的数组。与上一个算法的区别是，把互换a[i]和a[j]的地方，变成a[j] = source[i]::

	To initialize an array a of n elements to a randomly shuffled copy of source, both 0-based:
		for i from 0 to n − 1 do
			j ← random integer such that 0 ≤ j ≤ i
			if j ≠ i
				a[i] ← a[j]
			a[j] ← source[i]

原则
------------------
- 理解问题：跟用户交流，了解问题的上下文。问题的描述往往就包含解决方案。
- 抽象问题：将问题抽象化，首先有助于我们解决问题，其次有助于知道解决方案是否适用于其他问题。
- 尝试不同的设计：不要过早开始写代码。想想可能的解决方案，用伪代码写出来，选出合适的方案。
- 实现一个方案：实现最好的解决方案
- 自省：想办法提高你的方案


第13章 搜索
================================
本章以实现set为例，介绍了很多有搜索功能的数据结构

- 线性结构：数组与链表，前者支持随机访问，后者只能顺序访问；前者因为连续访问内存，容易预测，能更好利用缓存；后者容易扩展，但node中的指针等会占用更多的空间。
- 树：查找操作O(lgn)。平衡树例如AVL、红黑树能有效控制树的高度，避免最坏情况O(n)的出现。
- 位图bitmap：查找操作O(1)。缺点是必须知道要处理的数的最大上限；如果数据比较稀疏，会浪费空间。
- 散列表：将数组作为链表的索引。比如要存放[0, 1000)的数，就将[0, 100)的数存放到以数组第一个元素为头的链表中。控制了链表的长度，提高了性能。


第14章 堆
================================
本章讲了二项堆、优先级队列、堆排序。

- 效率：二项堆的性质是由其形状决定的，由父结点的位置直接可以计算出子结点的位置，不需要用树结构中的lchild、rchild指针，因此提高了效率。
- 抽象：将数据结构的接口与实现分开。比如优先级队列，可以有多种实现方法，但其接口不变。


第15章 字符串
================================
后缀数组Suffix Array
--------------------------
后缀数组（英语：suffix array）是一个通过对字符串的所有后缀经过排序后得到的数组。此数据结构被运用于全文索引、数据压缩算法、以及生物信息学。

假设有一个字符串"banana"，包含其所有后缀的数组，以及排序后的结果将是::

	0 banana                          5 a
	1 anana     Sort the Suffixes     3 ana
	2 nana      ---------------->     1 anana  
	3 ana        alphabetically       0 banana  
	4 na                              4 na   
	5 a                               2 nana

