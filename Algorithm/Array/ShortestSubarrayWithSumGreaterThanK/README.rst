Smallest subarray with sum greater than a given value
======================================================================
给定一个包含正整数的数组，和一个数k。找出一个最短的子数组，使其元素的总和大于k。


思路
----------------------------------------------
由于数组中只包含正整数，我们可以肯定，向子数组中添加元素，会让其元素总和变大；从任意子数组去除元素，会让其元素总和变小。

因此我们可以设置l = 0和r = 0两个下标，分别代表子数组的第一个和最后一个元素的下标。循环开始时，先让r递增(这代表子数组变长)，直到子数组的总和大于k为止。接下来，再让l递增(这代表子数组缩短)，直到子数组总和刚好大于k为止(l再前进一步，子数组的总和就会小于等于k了)。此时，arr[l..r]是我们能找到的符合条件的、以r结尾的最短子数组，将其长度r - l + 1与当前最短子数组结果相比，必要时更新一下。

之后，再让r前进，直到子数组总和大于k。再让l前进，直到子数组总和刚好大于k...重复这些操作，直到整个数组都被扫描过为止


允许负数
----------------------------------------------
若数组中包含负数，子数组长度变长，其元素总和反而可能减小；子数组长度变短，其元素总和反而可能增大。

其实我们只需要设置一个条件，丢弃总和为负数的子数组即可。假如有一个总和大于k的数组，其左端有一个总和为负数的子数组，那么可以将该子数组切除，以获得一个更短的数组，且总和更大。(由于我们从左到右搜索，因此右端不可能有总和为负的子数组，因为当总和大于k时，r就停止前进了)
