Bottom View of a Binary Tree
=========================================================
结点的水平距离：一个结点的左孩子的水平距离比父结点小1；一个结点的右孩子的水平距离比父结点大1。root的水平距离为0。

底部视角：当且仅当结点x是拥有给定水平距离的最靠近底部的结点时，x应当被加入到底部视角中。输出结果应当是按照结点的水平距离排序的。

解答
---------------------------------------
对树进行广度优先遍历(level order traversal)，并在遍历的同时，将{horizontal_distance: key}的键值对存入map结构中。最后，按照key的增序顺序，将map中所有的值打印出来。

关于map的选用，C++里有map和unordered_map两种：前者是红黑树，插入单个元素的时间复杂度为O(logn)；后者是哈希表，插入单个元素的时间复杂度为O(1)。我们选择unordered_map，使算法保持在O(n)时间复杂度。

但是，unordered_map中的key(水平距离)的存放是无序的。如何按照水平距离，增序地把结果打印出来呢？这需要用到结点水平距离的一个性质：所有结点的水平距离，都是从0开始，执行若干次+1或-1操作后计算出来的。也就是说，设树中最小的水平距离为leftmost，最大水平距离为rightmost，那么leftmost与rightmost之间的所有值都存在与unordered_map中。所以，我们只需要计算出leftmost和rightmost，然后令i从在[leftmost, rightmost]范围内递增，逐个从unordered_map中取出数据即可。

如何计算leftmost和rightmost呢？设置2个变量，遍历树的时候，将每个结点的水平距离与它们相比较即可。
