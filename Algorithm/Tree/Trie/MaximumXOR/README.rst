1 找出2个数，使得它们XOR的结果最大
=========================================================
给定一个数组，要求从中找出2个数，使得其XOR的结果最大。要求时间复杂度O(n)。

假设我们拥有这样一个数据结构，它拥有这样2种操作：

1. 插入一个数X
2. 给定一个数Y，在常数时间内找出已插入的数字中，与Y进行XOR的结果最大的数。

有了第一种操作，我们就可以把数都插入到该数据结构中；有了第二种操作，我们就能在常数时间内找到最大的XOR结果。Trie就是这样一种数据结构：

.. image:: images/insert.png

第一种操作：Trie插入一个长度为N的key需要O(N)时间。对于无符号整数来说，这个值为log2(MAX)，因为一个无符号整数至多有log2(MAX)个bit。因此，插入操作的时间复杂度实际上是常数级别的。

第二种操作：由于我们将数插入Trie时，是从最显著位(most significant bit)开始插入的，所以对于Y，要找出最大的XOR结果，就必须尽量让每一位的XOR结果为1，若不行再让其为0。这是贪心算法，由于我们从最显著位开始，让XOR的结果尽可能的大，所以最终结果必然是最大的XOR结果。此操作只需要一次查询，Trie每条路径的最高长度都为log2(MAX)，因此这个操作也是常数级别的。

.. image:: images/query.png

有了Trie这种数据结构，我们只需顺序扫描数组，将元素与已插入Trie的元素进行XOR，找出结果最大的(第二种操作)。扫描完成后，就能找出最大的XOR结果，以及相应的X与Y了。


2 找出一个子数组，使得里面所有元素XOR的结果最大
=========================================================
设F(L, R)为[L, R]范围内所有元素XOR的结果，那么有::

    F(L, R) = F(0, R) XOR F(0, L-1)

这很容易理解，设F(0, L-1)为a XOR b XOR c，F(L, R)为d XOR e XOR f XOR g。即::

    d XOR e XOR f XOR g = (a XOR b XOR c XOR d XOR e XOR f XOR g) XOR (a XOR b XOR c)
                        = (a XOR a XOR b XOR b XOR c XOR c) XOR (d XOR e XOR f XOR g)

设置一个变量xor，顺序扫描数组，每次令xor ^= array[i]，xor的值就是F(0, i)。使用第二种操作，找出Trie中与F(0, i)的XOR的最大结果，就是以i结尾的子数组所能达到的最大XOR结果。顺便还能找出相应的F(0, L-1)。


3 打印出所含元素XOR结果小于K的子数组的数量
=========================================================
此题类似上一个问题，但上一个问题是拿着F(0, R)的值，去Trie里找一个F(0, L-1)，使F(0, R) XOR F(0, L-1)最大；此问题则是要找满足F(0, R) XOR F(0, L-1) < K的F(0, L-1)的数量。

设置一个函数query(q, k)，表示Trie中满足以下条件的数字m的数量：q XOR m < k。

我们从最显著位开始，比较m与k的每一个对应的bit。假设k的当前bit为1，那么能让XOR结果的对应bit为0的所有m(即该分支下的所有叶子结点的数量)，都可以算在结果之内。

需要注意的是，有些子数组的XOR结果相同，它们存入Trie后的路径相同，所以不同的F(0, L-1)可能会被视为同一个数。为了正确统计结果，我们给每个TrieNode增加一个count成员，每次插入一个数，除了创建相应的node之外，还把路径的叶子结点的count值加1。统计结果时，加上所有符合条件的路径上的count值。
