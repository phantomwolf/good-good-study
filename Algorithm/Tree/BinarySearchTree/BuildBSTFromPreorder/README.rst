从先序遍历结果构建二叉搜索树
=============================================================
给定一个树的先序遍历结果pre[]，请构造一个二叉树出来。


O(n^2)递归方法
----------------------------------------------
先序遍历结果的第一个元素必然是root，首先构造出root。然后我们找到剩余元素中第一个比root大的元素(Next Greater Element)，设其下标为i，此元素必为root的右孩子。pre[0..i-1]都属于左子树，pre[i..n-1]都属于右子树。i将pre[]分为两部分，分别对两部分进行递归。

例如对于pre[] = {10, 5, 1, 7, 40, 50}，10是第一个元素，即root。第一个比root大的元素为40，那么5、1、7属于左子树，40、50属于右子树::

            10
          /    \
    {5,1,7}    {40,50}

分别对{5, 1, 7}和{40, 50}递归调用本算法：5为10的左子树的root，1属于5的左子树，7属于5的右子树；40为10的右子树的root，50属于40的右子树::

                        10
                      /    \
                     5      40
                   /  \       \
                  1    7       50


O(n)递归方法
----------------------------------------------
为每一个node设置一个取值范围[min..max]。在算法开始，将取值范围初始化为[INT_MIN..INT_MAX]，第一个结点必然在此范围内，用它创建root结点。要构建其左子树，将取值范围设置为[INT_MIN..root->val)，属于此范围的值，均属于左子树；要构建其右子树，将取值范围设为(root->val..INT_MAX]，属于此范围的值，均属于右子树。


O(n)迭代方法(推荐)
----------------------------------------------
本算法与验证一个二叉树是否为二叉搜索树类似。

设置一个栈，将第一个元素入栈，它就是root结点。将pre[]数组里第二个元素设为next，执行以下循环:

1. 当栈顶元素小于next时，持续进行出栈操作。令next为最后一个弹出的元素的右孩子(如果有的话)。
2. 若没有任何元素弹出，且栈不为空，next小于栈顶元素，那么令next为栈顶元素的左孩子。
3. 将next前进一位，从第1步开始。直到pre[]中所有元素都被处理为止。

对于pre[] = {10, 5, 1, 7, 40, 50}，我们来分析一下：

首先，我们用10创建root结点，目前树中只有一个root结点，将root入栈。

pre[1]是5，将其设为next。5小于栈顶元素10，适用于第2种情况。这种情况下，说明next是第一个比栈顶结点小的结点，即左孩子。将5入栈，开始下一轮循环。此时树的结构为::

            10
           /
          5

此时栈的内部为：[10, 5]。pre[2]为1，小于栈顶元素5，同样属于情况2，1是5的左孩子。将1入栈，开始下一轮循环。此时树的结构为::

            10
           /
          5
         /
        1

此时栈的内部为：[10, 5，1]。pre[3]为7，大于栈顶元素1。此为第1种情况，持续进行出栈操作，1和5先后出栈，最后一个出栈的为5。参考“下一个较大元素(Next Greater Element)”算法可知，7即为5的Next Greater Element，亦即O(n^2)算法中剩余元素中第一个比5大的元素，我们知道7必定为5的右孩子(7也是1的下一个较大元素，但根据O(n^2)算法，5出现得比1早，7为5的下一个较大元素，因此7在5的右子树上，而5与7中间的1在5的左子树上)。将7入栈，开始下一轮循环。此时树的结构为::

            10
           /
          5
         / \
        1   7

此时栈的内部为：[10, 7]。pre[4]为40，大于栈顶元素7。此为第1种情况，持续进行出栈操作，7和10先后出栈，最后一个出栈的为10。因此，40是10的下一个较大元素，40是10的右孩子，40与10之间的7属于10的左子树。将40入栈，开始下一轮循环。此时树的结构为::

            10
           /  \
          5   40
         / \
        1   7

此时栈的内部为：[40]。pre[5]为50，大于栈顶元素40。此为第1种情况，持续进行出栈操作，最后一个出栈的为40。因此，50为40的右孩子::


            10
           /  \
          5   40
         / \    \
        1   7   50

至此，pre[]中所有元素处理完毕，我们得到了二叉树。
