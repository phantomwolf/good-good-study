检查数组中元素是否能构成二叉搜索树的先序遍历
==================================================================
给定一个存放数字的数组A，若其中元素可以构成一个二叉搜索数的先序遍历结果，那么就返回true；否则返回false。期望的时间复杂度为O(n)。

思考一下，先序遍历是先访问结点，再访问其左子树，然后是右子树。那么，数组中第一个元素必定为root，在下例中为40。40的下一个较大元素为80，且之后的元素也都必须大于40。

::

        40
      /   \
    30    80
      \     \
       35   100

幼稚方案
------------------------------------------------------
找出当前元素的下一个较大元素(Next Greater Element)，设其下标为j。若以下条件可以保持下去，那么返回true，否则返回false：

1. A[j]之后的所有元素都比当前元素大
2. 递归地对子数组A[i+1..j-1]和A[j+1..n-1]调用本函数，结果也必须为true。

时间复杂度为O(n^2)


O(n)方案
------------------------------------------------------
思路与之前一样，若元素i的下一个较大元素下标为j，那么j以后的元素都必须大于A[i]。这次我们用类似Next Greater Element算法来做。设置一个变量root，表示当前子树的根的值，将其初始化为INT_MIN；设置一个栈。对A[]中每个元素A[i]执行下列操作：

1. 若A[i]比当前的root值小，返回false。
2. 当A[i]大于栈顶元素时，持续从栈中弹出元素。令最后一个弹出的元素为新的root。
3. 将A[i]压入栈(栈中所有元素呈降序排序)。

参考“从先序遍历结果构建二叉搜索树”算法，root与A[i]之间的元素属于root的左子树，A[i]到最后一个元素属于root的右子树。所以才要求A[i]及其后面的元素都要大于root。

但是，root是不断变化的，算法真的能保证后面的元素都大于某一次循环产生的root么？答案是肯定的。

设本轮循环要处理A[i]，最后一个弹出元素为root1，那么循环开始时，栈的内容是这样的::

    [x1, x2, root1, x3, x4, ...]，其中x1 > x2 > A[i]，A[i] > root1 > x3 > x4

由于A[i]比root1及其之后的元素要大，因此这些元素都被弹出。最后，A[i]被压入栈。此时，栈的内容为::

    [x1, x2, A[i]]，注意A[i] > root1

下一轮循环，假设A[i+1] > root1(这样算法才能继续下去)。假设x2 > A[i+1] > A[i]，那么这次最后弹出的元素为A[i]，也就是说新的root值为A[i]，设新的root为root2。那么A[i] = root2 > root1。下一轮循环中，我们就会要求A[i+2]必须大于root2了。既然A[i+2]大于root2，那么它必然也大于root1。

推论：root的值会越来越大。
