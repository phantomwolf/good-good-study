检查一个二叉树是否而二叉搜索树
====================================================
二叉搜索树是拥有以下性质的二叉树：

- 结点左子树中的所有结点，都比该结点的值要小
- 结点右子树中的所有结点，都比该结点的值要大
- 结点的左子树、右子树必须也为二叉搜索树

由以上性质可知，每个结点的值都是独一无二的。

1-错误的方法
----------------------------------------
检查每个结点的左孩子和右孩子，要求左孩子的值必须小于本结点，右孩子的值必须大于本结点。

用这个方法检查以下二叉树，结果是错误的::

        3
       / \
      2   5
     / \
    1   4

4大于3，不应该出现在3的左子树中，然而却是复合这个算法的要求的。因此，这个算法是错误的。

2-中序遍历
----------------------------------------
对树进行中序遍历，得到的结果若有序，就是二叉搜索树。时间复杂度O(n)。

不需要辅助数组来存储中序遍历的结果，我们只需要保证本次访问的结点比上一个的值大即可。


3-递归的同时限制最大/最小值
----------------------------------------
方法1的错误在于，不能保证左子树中的所有值都小于该结点，也不能保证右子树中的所有值都大于该结点。因此，我们可以给函数增加2个参数max和min，限制当前结点可以取的最大值和最小值。时间复杂度O(n)；若不考虑栈的大小，空间复杂度O(1)::

    int isBSTUtil(struct node* node, int min, int max)

同理，也可以写成这样::

    bool isBST(Node* root, Node* l=NULL, Node* r=NULL)

不传入min、max，而是传入相应的结点。min、max值可以由这些指针来获取。
